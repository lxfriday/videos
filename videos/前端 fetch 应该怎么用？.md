# 前端 fetch 应该怎么用？

- [前往视频](https://www.bilibili.com/video/BV1mm4y1F7xG)

兄弟们上期视频讲xhr讲了8分钟啊
如果再讲fetch
那视频内容肯定会超长
本期视频呢就接着讲fetch
视频的内容呢
也同样是依照这几个方面来进行
使用fetch发起一个网络请求
是非常简单的
它和xhr的使用体验完全是两码事
fetch总共有两个参数位
第一个参数一般是一个字符串
就是目标地址url
第二个参数是一个对象
用来添加对请求的各种配置
你也可以创建一个Request实例 
作为fetch的参数
而Request的参数和fetch 的参数是基本一样的
咱们发起请求
一般就把参数直接放到fetch里面就好了
至于第2个参数
还是有一点让人头皮发麻的
这配置是
too 多
fetch 的配置还是很难记的
method就是http请求的 请求方法
可大写可小写也可大小写
填错了也没事啊
它会甩个错误给你
兄弟们注意啊这个s不要漏了
要不然你配置的一堆headers
将会直接被忽略掉
可以给headers传递一个对象
请求发起的时候
浏览器会把你添加的对象
合并到HTTP的请求头里面去
如果你一不小心把headers的key给写重复了
那浏览器默认是用后者覆盖前者
body是用来添加请求体的
也就是请求需要传输的数据
这个地方实际上和xhr.send()差不多
body可以为
FormData 或者是 URLSearchParams
或者是普通的字符串
或者是json字符串
或者是其他的数据
fetch可以依据body
而自动推断出 content-type
但是这个推断能力也不是很完全
所以 body 对应的 content-type
最好还是自己填上
mode是一个枚举值
它可以是 cors
navigate no-cors 或者是 same-origin
从英语上翻译过来它叫做请求的模式
但是这不同的模式是干什么的
说真的很难直接推断出来
same-origin 表示发起的是一个同源请求
换句话说
当前页面所在的域名
和请求地址的域名是
必须相同的
如果两个地址对应的域名不同
即使是一级域名和二级域名的区别
它都会报错
no-cors 表示的是一个简单跨域 请求
或者是一个非跨域请求
在 x.com 发起这个请求的时候呢
请求是可以正常进行的
注意了哈
这是一个简单跨域请求
这个请求是可以正常的发送出去
并返回的
但是浏览器会把正常的返回内容给
全部隐藏
因为这个地方已经涉及到了
跨域相关的知识了
所以这期也不作深讲
那如果把mode改成cors
浏览器是会直接报错的
这相当于是把一个简单跨域请求
给直接改成了
跨域请求
必须要有服务端提供对跨域的支持
整个请求才能够正常进行
剩下的那个 navigte 咱就不讲了
那个是和页面跳转相关的
日常很少用到
大家有没有感觉这个 mode
有和没有好像没什么区别
实际上也大概是这个意思
model的默认值是cors
而当mode为cors的时候
你可以发起对同域名的请求
也可以发起对不同域名的请求
只不过在请求不同域名的时候
要注意在服务端配置cors策略
如果你的请求全部都是发往
同源的地址
那么这个mode你可以不用设置
又到了credentials 环节
credentials 的作用是在跨域请求的时候
决定是否发送cookie等信息
不同于xhr.withCredentials只有true和false两个参数 
fetch 的 crendentials 有三个枚举值
omit 表示任何时候都不发送cookie
same-origin表示
当前页面所在的域名和请求的域名
是相同时
才发送cookie
而include表示总是要发送cookie
这个好像没什么好说的
signal是和取消跨域请求相关的属性
请求取消之后呢会抛出一个  promise reject
fetch 取消请求的方式
看起来比较复杂
相比较之下
xhr对请求的取消则是简单很多
fetch 对请求的取消依赖于 AbortController
AbortController 的实例
拥有两个属性
其中一个就是signal
用来传递给fetch
另外一个则是abort()方法
用来主动取消请求
而取消事件的监听函数呢
则在abortSignal上面
这看起来是不是很绕
确实很绕
fetch 只是表面的简单
实际上可能比xhr更复杂
这不愧是xhr的替代品
fetch 的其他参数呢还有好几个
不过这些参数在日常的开发里面
用的是比较少的
这一看就是跟缓存相关的配置
通常在service worker里面使用fetch的时候
会用到这个属性
它能够控制本次请求的资源
是从浏览器缓存里面返回
还是从远程服务器上面获取
其他几个属性就不多说了
用的实在是太少了
前面说的这些就是fetch
第2个参数可以设置的属性
整体给人的感觉就是
简单使用的时候还是很简单的
复杂使用的时候呢
配置起来有一定的难度
接下来的内容呢
就是和fetch 请求返回相关的了
想要获取返回的http头信息呢
可以通过response.headers.get()来获取
想要获取本次请求的返回内容
比如本次请求返回的是一个jso n
则调用response.json()
而如果本次请求的是一个图片
可以调用response.blob()
得到blob格式的图片信息
然后再用 URL.createObjectURL()
把这个blob转成一个普通的url
注意哈
这个object url并不是图片的真实地址
fetch 其中并没有比较明确的事件函数
来监控上传和下载进度
而xhr则有
兄弟们这就有点难受了
虽然fetch中可以手中实现获取下载进度
但是多文件下载
大概率会把你写的代码给干崩溃
至于为什么没有直接实现
那咱就不知道了
难道是因为xhr里面已经有了
所以fetch不配拥有
说了将近5分钟
fetch的各种使用方式已经演示的 
足够到位了
最后上几个实例
好了那么本期视频到这里就结束了
感谢大家的观看
