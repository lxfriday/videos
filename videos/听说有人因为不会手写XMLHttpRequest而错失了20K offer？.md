# 听说有人因为不会手写XMLHttpRequest而错失了20K offer？

- [听说有人因为不会手写XMLHttpRequest而错失了20K offer？](https://www.bilibili.com/video/BV1kg411z7nD)

朋友们好久不见啊
因为本人身体的原因呢
也是好久没有更新视频了
不过没有关系哈
现在已经好的差不多了
接下来可以愉快的续更了
在开始之前一定要奉劝大家的是
千万不要因为任何事情
把自己给弄抑郁了
现在进入正题
在前端领域里面
没有任何一个人
可以避开网络请求这个概念
只要你的应用涉及到和服务器交互
就必然会用到这两者 
不过在日常的研发里面
你们接触最多的肯定是fetch和Axios
Axios是对底层网络请求API的一层封装
而fetch是对xhr的一个替代
在实际做研发的时候
直接使用XMLHttpRequest的情况是非常少见的
并不是说它  不能用
而是因为它不好用而又不得不用
俗话说初生牛犊不怕虎
你完全可以手写
纯原生的xhr来发起网络请求
只不过随着项目复杂度的提升
你可能会无休止地更改网络请求部分的代码
在浏览器运行环境中
js只能使用XMLHttpRequest
或者是fet ch发起网络请求
这个XMLHttpRequest别看它里面包含xml
实际上这个浏览器API已经与xml
没有必然联系了
因为本人嘴巴比较笨
所以后面用xhr代替XMLHttprequest
这是一个最最最朴素的xhr调用方法
实际用的时候谁都不会这么写的
放心看看就好
早期的时候使用xhr是因为只有xhr 
后来fetch出来了
浏览器里面新出现的功能
通常都会有兼容性问题
早期的时候其实没有多少人愿意去使用fetch
因为新的功能在
老浏览器上面根本就没有实现
如果你的用户有大量的旧版本浏览器
那使用这个新的功能
绝对是得不偿失的
不过随着科技的进步
以及一些新技术的严格要求
现在你把fetch用在自己的个人网站上面
是一点问题都不会有的
用fetch 发起一个比较简单的请求
fetch的写法是非常优雅
而且非常符合现代编码特征的
而使用xhr则需要走很多弯路
用xhr写网络请求 代码会非常的零散
这是一个非常高频的前端面试内容
虽然你几乎不可能在项目里面纯手写xhr 
而xhr也没有fetch更先进
但是就是会有面试官让你现场
纯手写一个xhr发起请求
原生的xhr
可以说是让很多前端新手
非常头疼的一个问题
还是那句话
它比较零散
它也拥有很多属性和方法
既然本期视频的内容就是xhr
那自然是不会让兄弟们空着手走的
从一个网络请求的发起
到接收到服务器返回的内容
通常会包括上面这几个方面
这里面是有相互包含关系的
在xhr实例生成之后
调用xhr.open()方法
就可以把网络请求的请求方法
和请求的目标地址给设置好
实际上你只需要写这三行代码
就可以把一个请求给发送出去
而后续你可以在xhr.onreadystatechange里面
根据服务器 返回的数据来做对应的处理
xhr.open()总共有5个参数
后面的三个参数
你在99.999%的时候都是用不到的
可以直接把它给忽略掉
第一个参数method就是请求方法
第二个参数url表示就是目标地址
接下来就是返回内容
从这个地方开始就会有非常多的槽点
左边fetch
获取返回内容是非常明白直接的
而右边xhr
获取返回内容则必须在xhr.onreadystatechange 里面
而且必须要等待它它的readyState为4的时候
才可以获取到返回的内容
但从这一点上看xhr显得非常的繁琐
把xhr做一层promise化的封装之后
它是可以做到基本和fetch的用法一致的
xhr.send()的是用来发送请求体的
要注意的是
GET请求是不会发送请求体的
即使你在xhr.send()中添加了参数
而对于像POST或者是PUT这两种请求方法 
就可以把需要发送的数据
放到xhr.send()中作为参数
通过抓包就可以看到
需要传输的数据
全部放在了http头的后面
xhr.send()的参数类型可以有好几种
常用的是字符串、URLSearchParams和FormData
一般就是右边这四种 content-type
要注意的是 作为xhr.send()的参数
json字符串和普通字符串
所表现出的行为是不一样的
xhr.send() 会依据参数
来自动设置content-type类型
普通字母串会设置成text/plain 
而json字符串会设置成application/json
这是一个处理xhr状态变更的监听函数
xhr总共有下面5种状态
当xhr.readyState为4的时候
表示下载已经完成了
这个时候就可以通过xhr.response 
获取从服务端返回的内容
也就是返回题
用红框框住的部分
就是本次请求的返回体
不知道你们有没有发现
通过查看原始文本来分析http请求
好像网络协议什么的也没有那么难
是吧
这个xhr方法的命名非常的直观
它的作用是设置http请求的头信息
它就是用来设置headers信息的
对比xhr和fetch
很明显fetch更加的直观
这个方法不用我说
你们也应该明白是什么意思了
它可以用来获取
服务器返回的http头信息
这里有一个你不太需要知道的点
xhr.getResponseHeader()的参数字母串是不区分大小写的
但它不是神仙啊兄弟们
如果中间漏  了一个横杠
它是肯定识别不出来的
这又是一个即使我不说你们也能猜到的api接口
取消嘛 对吧 可以调用它来停止xhr请求
请求取消之后
在浏览器的网络监控栏
是可以看到有一条取消记录的
这是三个和返回内容有关的属性
其中
responseType和另外两个稍微有一点区别
它是用来设置返回内容的格式的
换句话说
设置了responseType
浏览器才知道
返回的内容应该怎么处理
在不设置这个属性的时候默认就是text
服务器返回的内容可以在xhr.response中获取到
在responseUrl中
可以获取到本次请求的地址
xhr.status可以用来获取HTTP响应码
而statusText则是对应的响应状态信息
实际上
它对应的就是HTTP响应的头一行
很明显这是和请求超时相关的属性
要是一个请求发出去
服务器一直都没有响应
那业务逻辑就没法进行下去了对吧
timeout的单位是毫秒
当你设置了超时时间
和超时事件函数之后
只要请求超过了这个时间
就会触发对应的事件函数
这是一个和跨域请求相关的属性
至于什么是跨域呢
这个可以单独做一期视频来讲
那本期视频呢就不要跑偏了哈
它是用来控制
是否允许浏览器发送cookie 到服务端的
xhr.withCredentials这个属性
对于同域名的网站是没有任何作用的
说的直白一点
既然页面的地址和服务端的地址
都属于同一个域名下
那就直接把cookie
发到自己的服务器上面就完事了
而如果当前页面请求的是不同域名下的地址
当设置xhr.withCredentials为false或者是不设置的时候
发送的请求不会携带cookie信息
而把xhr.withCredentials设置为true 之后
你们猜一猜会出现什么情况
兄弟们它会报错哦
这是一个跨域请求
那自然是不能只改前端不改后端的
贴一个最简单的测试代码
红框框住的3条是必须要设置的
而且其中的access-control-allow-origin
必须指定为具体的域名地址
这一不小心
又涉及到了跨域中
非常重要的一个部分
咱们后面再讲
这期视频不涉及
服务端设置好之后呢
cookie信息就会自动地带上了
你可以给xhr设置各种事件函数 
这些函数会在指定的阶段被调用
这里面用的最频繁的是xhr.onreadystatechange
和xhr.onprogress
xhr.onreadystatechange在前面已经有说到了
而xhr.onprogress是用来检测下载进度的 
当我们想要检测
文件的下载进度的时候
可以通过loaded的和total
来计算出当前的下载进度
这个e是ProgressEvent的一个实例
其中lengthcomputable表示
下载的内容是否有可以计算的长度
loaded表示已经下载的大小
而total表示要传输数据的总大小
做个除法就可以知道传输进度了
本期视频到这里
XMLHttpRequest就已经讲完了
不知道兄弟们有多少收获呢
给大家贴一段代码
fetch作为xhr的替代品
它最直观的特征就是整个使用过程是promise化的
而且它对请求的配置和返回的处理都非常的固定
短短的两行代码
就可以把需要的数据给拿到
非常的简洁
兄弟们fetch我就不做过多介绍了
这个进度条已经快到8分钟了
有点编不动了
要不本期的视频到这里就结束了
感谢您的观看
咱们下期也很..
