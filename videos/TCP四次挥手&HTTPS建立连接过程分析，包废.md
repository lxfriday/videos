# TCP 四次挥手&HTTPS 建立连接过程分析，包废

- [前往视频](https://www.bilibili.com/video/BV1xG4y147G9)

上期视频中
把 TCP 3 次握手
非常详细地分析了一遍
兄弟们表示看不懂
呃可能是上期视频说的太多了吧
那这期视频呢
讲 4 次挥手就稍微简单一点讲
同时呢
把 HTTPS 建立连接的过程也一起看一遍
TCP 的握手和挥手过程
都会有特殊的标志位
握手的时候
客户端和服务端
发送给对方的首个包中
都需要 SYN 标志位为 1
而挥手的时候
也同样需要
发送给对方一个特殊的标志位
那就是 FIN
FIN 表示的就是 finished
在这个图里面
客户端先向服务端发出一个 FIN
标志位为 1 的包
服务端收到这个包之后
并不会立即也返回一个
FIN 标志位为 1 的包
服务端先是返回一个
ACK 标志位为 1 的包
这表示的是
服务端收到了
客户端发出的断开连接的通知
这里服务端作为断开连接的被动方
它可能还有一些数据没有收发完
等服务端这边的数据
也全部收发完成之后
服务端才会发送一个
FIN 标志位和 ACK 标志位都为 1 的包
这个包中的 ack number
它的值等于前面发送给客户端中 ack number 的值
这两个 ack number 都等于图中的 u+1
实际上就是客户端首次发送的包中
seq number 的值加 1
这里大写的 ACK 是标志位
小写的 ack 它的全称叫 acknowledgement number
我们经常能听到的标志位有 SYN ACK FIN
而 ack number 和 seq number
这两者都是一串比较长的数字
当客户端收到 FIN 标志位为 1 的包之后
客户端最后会发送给服务端一个 ACK 标志位为 1 的包
服务端收到这个包之后
4 次挥手的过程就完成了
可以看到
服务端和客户端都需要发送给对方
一个 FIN 标志位为 1 的包
而作为接受方
两端也都需要发送给对方一个 ACK 标志位为 1 的包
关于 4 次挥手过程中的 seq number 和 ack number
有几串数字是需要严格对应的
首先第一次挥手的时候 seq number 为 u
这个 u 具体的值咱们不用管
在第二次挥手的时候
服务端发出的包中 ack number 的值
必须等于前面 seq number 的值加 1
第三次挥手的时候
ack number 值还是要等于 u+ 1
在第 3 次挥手的时候
已经明确标出了 seq number 和 ack number
所以作为第 3 次挥手的回应
在第 4 次挥手中
seq number 值等于第 3 次挥手 ack number 值
而 ack number 值等于第 3 次挥手 seq number 值加 1
至于 seq number 和 ack number 的生成和计算
在上期视频里面也有讲过
本期视频就不多说了
兄弟们实际上
握手和挥手
都是存在非常严格的对应关系啊
握手是都需要发送给对方一次 SYN 标志位为 1 的包
而对方也需要回应一个 ACK 标志位为 1 的包
只不过在第 3 次握手的时候
SYN 和 ACK 标志位都为 1 的包合并到了一起
发送给了客户端
在第 4 次挥手的时候
都需要发送给对方一个
FIN 标志位为 1 的包
表示要分手了
对方呢
也都需要回应一个 ACK 标志位为 1 的包
表示哦我知道了
所以等两边都知道之后
那这个分手就确定了
4 次挥手为什么需要 4 次呢
这是因为接收方在知道要分手之后
它只能先回答你我知道了
等它把和你相关的所有信息全部删除
bank 密码也改了之后
它才会再发一个消息跟你说
那么就分手吧
然后你再做一个回应
好吧 那我们就结束了
兄弟们这个比喻还行吧
相信你们应该能
大体感知到这个过程了
3 次握手和 4 次挥手就讲完了
在面试的时候
还会有一个更高阶一点的问题
那就是请你描述一下 HTTPS
建立连接的过程
这个问题
在前几年我面试鹅厂的时候就碰到过
HTTPS 建立连接的过程比较复杂
而且会涉及到密码学
加密等等一些东西
所以说问到这个问题 通常还是比较难受的
HTTPS 会涉及到对称加密和非对称加密两个概念
它们具体是什么意思呢
这个到网上一查就可以查到
在视频里面说起来会比较费劲啊
这里就简单说一下这两个加密
在 HTTPS 里面的应用
在 HTTPS 握手阶段会应用非对称加密
而在数据传输阶段应用的是对称加密
非对称加密的性能损耗非常大
但是它的安全性很高
经常听到的两个非对称加密算法
一个是 RSA 一个是 ECC
不过在抓包的时候 ECC 比较常见
后面分析的时候也可以看到它的子算法 ECDHE
这张图描述的就是使用 ECDHE
来进行 HTTPS 握手的过程
在 wireshark 中
能够看到 HTTPS 详细的握手过程
这里 HTTPS 握手的过程总共有 5 个包
这 5 个包可以分为四个阶段
还是那个说法
HTTPS 握手很复杂
所以后面尽量分析大家能看懂的内容
在建立连接的第一个阶段
客户端发出一个 Client Hello 的包
其中包含 5 个重要信息
TLS 版本 一个随机数
加密套件列表
压缩方法列表以及扩展列表
这个随机数是用来生成
后面对称加密密钥的
在第 2 个阶段
服务端先发出了一个 Sever Hello 的包
这个包中包含确认使用的 TLS 版本
一个随机数
确认使用的加密套件
压缩方法以及确认使用的扩展列表
Sever Hello 和 Client Hello 的内容
它们是基本对应的
通过这两个包
就基本确定了协议版本和加密算法
紧接着
服务端还会发出一个 Sever Hello Done 的包
包里面会包含一个证书
以及一个 Sever Params
这里就涉及到了 ECDHE 算法
因为本人对这个算法也不是很了解啊
咱们这里主要关注这个 Pubkey 这个字段
总之呢就是
服务端发给了客户端一个
非对称加密算法的公钥
在第 2 个阶段
服务端发给客户端的信息非常的多啊
在第 3 个阶段
客户端收到服务端的 Sever Params 之后
客户端也会发送一个 Client Params
这也是一个 ECDHE 算法的公钥
另外还有一个 Change Cipher Spec
和一个 Encrypted Handshake Message
通过这两者告诉服务端编码改变
以及握手结束
现在来到最后一个包
服务端也会给客户端回一个 Change Cipher Spec
和 Encrypted Handshake Message 包
至此呢
HTTPS 建立连接的过程就结束了
在之后双方传输的包中
就只有 Application Data
兄弟们这不得不说啊
HTTPS 建立连接的过程
属实是非常难以看懂啊
咱们再回到这张总览图
在握手的过程中
客户端和服务器都会发送给对方一个
random 随机数
同时呢通过 Sever Key Exchange 和 Client Key Exchange
两个端又给对方发送了各自的公钥
这样呢
两个端就可以使用两个 random 随机数
加上两个公钥(Server Params、Client Params)
计算出后面的使用对称加密算法时候的密钥(yue 月)
好了兄弟们我已经说不下去了
这简直不像是一个前端程序员
应该了解的东西
在第 3 个阶段
客户端比如说浏览器
拿到服务端发送过来的证书以后
会验证证书有效期
证书是不是可信机构颁发的
以及证书和域名是否匹配
如果说证书验证不通过的话
浏览器就会给出提示
那么最后对 HTTPS 建立连接过程做个总结
因为本人对网络这方面
也不是特别熟悉
如果内容有错误的话
本期视频到这里就结束了
