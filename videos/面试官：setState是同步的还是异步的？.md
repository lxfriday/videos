# 面试官：setState是同步的还是异步的？

- [前往视频](https://www.bilibili.com/video/BV1MW4y1u7Um)

1
00:00:00,133 --> 00:00:01,799
兄弟们如果你们使用过react

2
00:00:01,800 --> 00:00:02,900
做前端项目的话

3
00:00:02,900 --> 00:00:04,866
那给自己封一个setState工程师

4
00:00:04,866 --> 00:00:05,766
应该不过分吧

5
00:00:05,766 --> 00:00:07,799
这几行代码你们应该是非常熟悉了

6
00:00:07,800 --> 00:00:08,766
关于setState呢

7
00:00:08,766 --> 00:00:10,333
有一个经常出现的面试题啊

8
00:00:12,566 --> 00:00:13,733
通常我们的第一反应呢

9
00:00:13,733 --> 00:00:15,199
那肯定setState是异步的

10
00:00:15,200 --> 00:00:16,900
比如说在这个合成事件里面

11
00:00:16,933 --> 00:00:18,333
先后两次setState

12
00:00:18,333 --> 00:00:20,699
但是两次的console.log打印出来都是0

13
00:00:20,700 --> 00:00:22,333
这是因为setState设置的值

14
00:00:22,333 --> 00:00:24,666
会在函数执行结束之后再进行合并

15
00:00:24,666 --> 00:00:25,933
然后再更新到页面上

16
00:00:25,933 --> 00:00:27,466
在这个事件函数执行的时候

17
00:00:27,466 --> 00:00:29,133
是不会立即改变state的值的

18
00:00:29,133 --> 00:00:30,299
如果你给出这个回答

19
00:00:30,300 --> 00:00:31,900
只能说答对了一半

20
00:00:31,900 --> 00:00:32,500
实际上呢

21
00:00:32,500 --> 00:00:35,000
setState是存在同步和异步两种情况的

22
00:00:35,000 --> 00:00:36,900
虽然同步的情况出现的比较少啊

23
00:00:36,900 --> 00:00:39,533
setState在合成事件和生命周期函数中呢

24
00:00:39,533 --> 00:00:40,066
是异步的

25
00:00:40,066 --> 00:00:41,666
也就是说使用了setState之后

26
00:00:41,666 --> 00:00:42,933
马上获取对应值的话

27
00:00:42,933 --> 00:00:44,266
是拿不到最新的值的

28
00:00:44,400 --> 00:00:46,366
那在哪些情况下setState是同步的呢

29
00:00:46,366 --> 00:00:47,966
在自己绑定的原生事件

30
00:00:47,966 --> 00:00:49,299
或者是定时器中

31
00:00:49,400 --> 00:00:50,700
setState是同步的

32
00:00:50,700 --> 00:00:51,700
在这两种情况下

33
00:00:51,700 --> 00:00:52,933
setState执行之后

34
00:00:52,933 --> 00:00:54,399
紧接着获取对应的值的时候

35
00:00:54,400 --> 00:00:55,800
是可以拿到最新的值的

36
00:00:55,800 --> 00:00:57,500
咱们依然是用例子来做分析啊

37
00:00:57,500 --> 00:00:59,333
初始情况下cnt (count)的值是0

38
00:00:59,400 --> 00:01:01,266
handleClick1 是一个比较普通的函数

39
00:01:01,266 --> 00:01:02,733
会走合成事件的逻辑

40
00:01:02,733 --> 00:01:04,466
那点击这个合成事件按钮之后

41
00:01:04,466 --> 00:01:05,866
两次打印的结果是什么呢

42
00:01:05,866 --> 00:01:06,699
都是0对吧

43
00:01:06,700 --> 00:01:07,733
因为两次打印的时候

44
00:01:07,733 --> 00:01:08,766
获取到的cnt的值

45
00:01:08,766 --> 00:01:09,599
并没有更新啊

46
00:01:09,600 --> 00:01:10,866
所以获取到的还是初始的0

47
00:01:10,900 --> 00:01:12,800
一些刚接触react的兄弟们

48
00:01:12,800 --> 00:01:14,000
可能就会犯这个错误吧

49
00:01:14,000 --> 00:01:15,500
如果想要在这个值更新之后

50
00:01:15,500 --> 00:01:16,566
再做一些处理呢

51
00:01:16,566 --> 00:01:18,466
你可以在setState的第二个参数

52
00:01:18,466 --> 00:01:19,666
添加一个回调函数

53
00:01:19,666 --> 00:01:21,933
这样获取到的state就是更新过后的了

54
00:01:23,066 --> 00:01:24,933
在我们自己绑定的原生事件中呢

55
00:01:24,933 --> 00:01:26,966
react就不会给你做状态合并

56
00:01:27,066 --> 00:01:29,699
执行setState之后state的值会马上变更

57
00:01:29,700 --> 00:01:31,466
所以初始状态下是0

58
00:01:31,500 --> 00:01:32,700
执行一次之后是1

59
00:01:32,700 --> 00:01:34,366
然后再执行一次就变成2了

60
00:01:34,566 --> 00:01:35,399
在定时器中呢

61
00:01:35,400 --> 00:01:37,500
也同样是会先打印1后打印2

62
00:01:37,500 --> 00:01:38,366
那关于定时器呢

63
00:01:38,366 --> 00:01:39,866
可能看起来有点特殊啊

64
00:01:39,866 --> 00:01:41,333
因为这个定时器是设置在

65
00:01:41,333 --> 00:01:42,266
合成事件中的

66
00:01:42,266 --> 00:01:43,566
那它对于state的合并

67
00:01:43,566 --> 00:01:45,566
为什么不走合成事件的那套逻辑呢

68
00:01:45,733 --> 00:01:47,366
这个还真挺难的

69
00:01:47,366 --> 00:01:48,699
我们可以先猜一猜啊

70
00:01:48,700 --> 00:01:50,566
因为js中存在事件循环

71
00:01:50,566 --> 00:01:52,199
而执行到setTimeout的时候

72
00:01:52,200 --> 00:01:53,900
setTimeout回调函数中的代码

73
00:01:53,900 --> 00:01:55,066
并不会立即执行

74
00:01:55,300 --> 00:01:57,366
这段代码会在指定的延迟时间过后

75
00:01:57,366 --> 00:01:58,933
再被放入到执行队列中

76
00:01:58,966 --> 00:01:59,566
好吧兄弟们

77
00:01:59,566 --> 00:02:00,866
这里又涉及到了另外一个

78
00:02:00,866 --> 00:02:01,866
非常重要的js面试题

79
00:02:01,866 --> 00:02:03,199
关于事件循环呢

80
00:02:03,200 --> 00:02:04,733
这里就举一个例子说一下

81
00:02:04,766 --> 00:02:07,099
这段代码在浏览器中的执行结果是这样的

82
00:02:07,100 --> 00:02:08,666
在执行这段代码的时候

83
00:02:08,666 --> 00:02:10,499
Promise 这个构造函数的参数

84
00:02:10,500 --> 00:02:12,800
会像正常的同步代码一样立即执行

85
00:02:12,866 --> 00:02:14,299
所以最先打印出了promise

86
00:02:14,300 --> 00:02:16,300
而promise.then中的回调函数呢

87
00:02:16,300 --> 00:02:17,800
会被放到宏任务队列中

88
00:02:17,800 --> 00:02:19,566
等同步代码执行完成之后呢

89
00:02:19,566 --> 00:02:21,133
就会执行宏任务队列中的任务

90
00:02:21,133 --> 00:02:23,666
所以紧接着不会打印promise1和promise2

91
00:02:23,666 --> 00:02:25,299
而是打印script end

92
00:02:25,500 --> 00:02:26,800
现在同步代码执行完了

93
00:02:26,800 --> 00:02:30,166
接着就会把宏任务队列中的promise1和promise2打印出来

94
00:02:30,200 --> 00:02:31,200
这个定时器呢

95
00:02:31,200 --> 00:02:32,500
虽然是放在最前面的

96
00:02:32,500 --> 00:02:34,500
由于定时器中的回调函数会放到

97
00:02:34,500 --> 00:02:35,333
微任务队列中

98
00:02:35,466 --> 00:02:36,766
微任务会在同步代码

99
00:02:36,766 --> 00:02:38,333
和宏任务执行完成之后

100
00:02:38,333 --> 00:02:38,799
才执行

101
00:02:38,800 --> 00:02:41,400
所以promise2打印之后才打印的setTimeout

102
00:02:41,700 --> 00:02:43,500
这个事件呢看起来虽然比较绕啊

103
00:02:43,500 --> 00:02:44,400
但是并不难

104
00:02:44,400 --> 00:02:46,400
那么回到这个合成事件中的定时器

105
00:02:46,400 --> 00:02:46,966
很显然啊

106
00:02:46,966 --> 00:02:48,166
定时器中的回调函数

107
00:02:48,166 --> 00:02:50,533
会在handleClick2函数执行完成之后

108
00:02:50,533 --> 00:02:51,333
才会执行

109
00:02:51,366 --> 00:02:52,766
那我们大胆猜测的话

110
00:02:52,766 --> 00:02:55,066
handleClick2 这个函数执行完成之后

111
00:02:55,066 --> 00:02:57,066
react内部就关闭掉某个设置

112
00:02:57,066 --> 00:02:57,299
然后

113
00:02:57,300 --> 00:02:59,400
这个定时器中的回调函数执行的时候

114
00:02:59,400 --> 00:03:01,933
setState执行一次就会更新一次state

115
00:03:02,066 --> 00:03:03,133
那么视频说到这里

116
00:03:03,133 --> 00:03:05,066
讲道理应该分析分析源码了

117
00:03:05,066 --> 00:03:06,766
经过本人一个下午的努力呢

118
00:03:06,766 --> 00:03:08,199
我还是决定放弃了

119
00:03:08,200 --> 00:03:08,600
兄弟们

120
00:03:08,600 --> 00:03:11,066
这框架的源码属实是太复杂了呀

121
00:03:11,166 --> 00:03:12,799
看了半天完全没有头绪啊

122
00:03:12,800 --> 00:03:15,300
另外呢由于react框架版本的变化

123
00:03:15,300 --> 00:03:16,866
网上的一些对源码的分析

124
00:03:16,866 --> 00:03:18,999
在react 18中已经不太适用了

125
00:03:19,000 --> 00:03:20,966
最后呢再说一个我发现的问题吧

126
00:03:20,966 --> 00:03:22,599
在最新版本的react中

127
00:03:22,733 --> 00:03:24,933
已经不推荐使用ReactDOM.render了

128
00:03:24,933 --> 00:03:26,899
现在使用react-dom/client

129
00:03:26,900 --> 00:03:27,966
来导出ReactDOM

130
00:03:27,966 --> 00:03:30,899
使用ReactDOM.createRoot来挂载根结点

131
00:03:30,900 --> 00:03:31,900
然后再render

132
00:03:31,966 --> 00:03:34,166
根结点的挂载方式发生变更之后呢

133
00:03:34,200 --> 00:03:36,800
这个变更对setState的行为有一些影响啊

134
00:03:36,800 --> 00:03:38,933
没有使用这个新的挂载方式的时候

135
00:03:39,100 --> 00:03:40,800
定时器中setState它是同步的

136
00:03:40,800 --> 00:03:42,533
但是在用了这个新的挂载方式之后

137
00:03:42,533 --> 00:03:44,166
定时器也变成异步的了

138
00:03:44,166 --> 00:03:46,933
这里只有自己绑定的原生事件才是同步的

139
00:03:46,933 --> 00:03:48,566
在文档里面有提到这么一句话

140
00:03:48,566 --> 00:03:49,199
那推测呢

141
00:03:49,200 --> 00:03:51,466
可能就是这个新的渲染模式导致了

142
00:03:51,466 --> 00:03:52,866
setState行为的变化

143
00:03:52,866 --> 00:03:54,566
好了本期视频到这里就结束了

144
00:03:54,566 --> 00:03:56,199
感谢大家的观看拜拜

