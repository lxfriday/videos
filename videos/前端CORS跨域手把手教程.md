# 前端CORS跨域手把手教程

- [前往视频](https://www.bilibili.com/video/BV1M84y1v7qH/)

跨域问题是前端领域里面非常重要
而且非常高频的一个面试问题
就这么说吧
如果你面试的时候
碰到了一个跨域的问题
但是你没有答上来
那么恭喜你
你可以考虑投下一家公司了
跨域本质上并不是一个太难的问题
无非就是当前页面所在的源
和请求的目标地址
所在的源不同
然后呢浏览器就以各种理由
让你的请求给挂掉
再之后呢
你为了达到自己的目的
想方设法和浏览器斗智斗勇
要么使用浏览器安全策略允许的方式
发起请求
要么就是使用一些小技巧
来躲开浏览器的安全策略
总之呢
一个请求要是涉及了跨域问题
那你就得稍微多花一点功夫
在这个请求的处理上
对于网页上的一个请求
只要这个请求的协议或者域名
或者端口与当前页面不同
那浏览器就会认为这是一个
不可靠请求
请求发出去的时候
浏览器就会对这个请求进行各种限制
一旦浏览器检测到你的请求
可能存在安全风险
那浏览器就会把你的请求给挂掉
浏览器会对所有的请求一视同仁
因为它根本不知道你这个请求是
正常的请求还是恶意的请求
针对这种一定要往
不同的源上发请求的情况呢
浏览器给出了一个比较正式的解决方案
英文缩写叫做CORS
一个跨域请求有可能会
触发一个额外的OPTIONS请求
所以依据于是否会触发OPTIONS请求
把跨域请求分为简单请求
和非简单请求
对于所谓的简单请求和非简单请求呢
要注意一点
它都是跨域的
这句话有点像是废话
但是你不要以为
简单请求就不需要后端做配置了
虽然服务端能够正常返回
但是浏览器也会直接给你报错
像这种简单请求呢
只需要在服务端返回的HTTP头里面
加上access-control-allow-origin就可以了
通常如果你发起的请求中
只有请求方法和目标地址
这就是一个简单请求
MDN上对简单请求也有比较科学的定义
也就是说
如果你的请求方法是GET HEAD
或者是POST中的一个
而且你的请求头中设置的属性不超过这4个
其中content-type属性使用的是这3个中的一个
那你发起的跨域请求
就是一个简单跨域请求
要特别注意啊
application/json是没有包含在内的
你只要加上了json这个请求头
那针对简单跨域请求的配置就会失效
换句话说
你在服务端的返回头中
得配置更多的属性
非简单请求嘛
就是
不是简单请求的请求就是非简单请求
因为有一些跨域请求
需要在请求头中添加额外的参数
或者是传输的数据是json
或是其他类型
这样的请求就超出了简单跨域请求的约束
浏览器检测该跨域请求的时候
就会出现错误
这个错误是在浏览器发起
预检请求的时候出现的
那预检请求又是个什么玩意呢
浏览器在发起非简单跨域请求的时候
会额外发送一个请求叫做预检请求
这个请求的请求方法是OPTIONS
在预检请求的acess-control-request-headers里面
会添加上我们额外设置的请求头
而access-control-request-method
是本次请求的请求方法
要注意了哈
这个预检请求
并不是我们自己能控制的
它是浏览器对于非简单跨域请求的一种探测行为
同时呢因为非简单跨域请求
会发送预检请求和本体请求两次请求
所以服务端要注意
当请求方法为OPTIONS的时候
只需要返回HTTP头就可以了
而当检测到当前请求是本体请求的时候
再做业务处理
到这里肯定会有个问题
那就是服务端怎么应答预检请求呢
服务端主要通过这6个字段
告诉浏览器
本次请求有什么操作是被允许的
有什么操作是不被允许的
access-control-allow-origin用来控制允许访问的源
对于跨域请求
服务端返回的头信息中
必须包含这个字段
如果它的值是一个*
那就表示允许所有源访问
也可以指定成具体的源
对于浏览器来讲
只要协议或者域名或者端口有所不同
那都无法通过匹配
这个地方第一次服务器返回的协议不同
第二次服务器返回的端口不同
浏览器都出现了错误
另外呢当发起的请求
是一个需要携带cookie的跨域请求时
服务端返回的access-control-allow-origin信息
不能为*
必须指定为具体的源
access-control-allow-methods用来控制
允许的请求方法
预检请求中的access-control-request-method
表示本次请求的请求方法
HTTP请求的请求方法有这8种
其中GET POST HEAD
即使不在access-control-allow-methods里面
也照样可以成功发送跨域请求
而如果发起的跨域请求
请求方法是PUT DELETE OPTIONS
那就必须要在access-control-allow-methods
里面进行明确的设置
这里服务端额外允许的请求方法是DELETE
而前端使用的是PUT
所以请求失败了
这里虽然access-control-allow-methods只有DELETE
但是POST方法照样是可以请求成功的
实际上从简单请求和非简单请求的区分上来看
就知道了
只要你的请求的请求方法或者是头信息
满足简单请求的要求
就有不太额外需要服务端的配置
除了access-control-allow-origin这个字段是必配的
兄弟们不知道你们有没有注意到啊
预检请求本身就是一个OPTIONS事情
但是OPTIONS请求
即使不在access-control-allow-methods里面
它照样是可以请求成功的
这个OPTIONS请求
是浏览器层面的OPTIONS请求
并不是我们自己业务的OPTIONS请求
所以浏览器会放这个OPTIONS预检请求过关
那如果我们自己发起一个OPTIONS请求
很显然
浏览器会把这个OPTIONS请求给挂掉
兄弟们可以好好品一品
两种OPTIONS请求的区别
这个字段控制是否允许浏览器发送cookie
如果你在一个跨域请求中
需要带上cookie
咱们这里有一个前提啊
就是目标源的cookie可以在当前源发送出去
比如说咱们在a.com请求api.a.com
这里有一部分cookie是可以发送到服务端的
那如果在a.com 
请求b.com那就没有cookie 能够发送出去
这里涉及到了cookie的安全策略问题
这个问题就不多讲了哈兄弟们
那在a.comn请求api.a.com
 想要cookie能够发送出去
前后端都需要配置
前端如果使用的是fetch
那就把credentials 设置为include
如果使用的是XHR
那就把withCredentials设置为true
后端部分呢
需要添加access-control-allow-credentials字段
它的值呢设置成true或者'true'都可以
这样一个跨域请求就能够带上cookie了
反之呢如果服务端没有设置这个字段的话
前端就会报错
这一看就是跟请求头相关的字段
在发起跨域请求的时候
由于业务要求
可能会需要额外带上一些请求头信息
这些请求头
是属于简单跨域请求之外的头信息
任何你使用到的额外的头信息
都必须要包括在access-control-allow-headers里面
假如说我手痒添加了一个requestSession
同时呢服务端的access-acontrol-allow-headers 里面
并不包括这个requestSession
那么很显然浏览器又会找你麻烦
兄弟们啊
我属实没想到
讲个CORS居然讲了6分钟还没有讲完
还有两个字段
再加把劲吧
这个属性是控制预检请求的有效期的
咱们前面说到
跨域请求它会发送一个预检请求
和一个本体请求
实际上
你可以让这个预检请求的有效期
持续一段时间
在有效期内
当你向相同的源发起请求的时候
就不用发送预检请求了
access-control-max-age的单位呢是秒
在不同浏览器里面
这个缓存时间的上限有所不同
这个字段一看就知道是什么意思
就是服务端允许
跨域请求能够访问到的HTTP头信息
没有设置这个字段的情况下
打印response.headers 的时候
里面根本就没有headers信息
而实际上呢它是有4条的
然后我给access-control-expose-headers
添加了3个头信息
这样前端就可以获取到我所
指定的HTTP头信息了
好了兄弟们到这里
关于CORS如何配置
已经完全讲清楚了
就这6个字段
那么本期视频到这里就结束了
下期视频呢
咱们继续分析另外的几种跨域方式
