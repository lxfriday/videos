# 前端浏览器缓存手把手教程

- [前往视频](https://www.bilibili.com/video/BV1r24y127M3/)


今天我们来聊一聊
浏览器缓存相关的内容
浏览器缓存
也是前端面试里面必须要会
而且出现概率非常高的内容
相比于前面几期视频中的cookie
或者是跨域
浏览器缓存并没有那么难啊
浏览器缓存相关的字段
一共也才这么几个
在了解这些字段之前
那我们要清楚两个概念
浏览器会先检查强缓存
然后再检查协商缓存
如果本地缓存的资源
经过强缓存检查之后是有效的
那浏览器就会直接返回缓存的内容
浏览器甚至都不会把这个对
资源的请求
发送出去
如果（在浏览器地址栏）直接请求一个本地已经
缓存过的资源
或者cache-control中包含no-cache
那么浏览器向这个
资源地址发起请求的时候
如果这个资源没有发生任何变动
那服务端通常会返回304状态码
并且返回体中不需要携带任何信息
浏览器在接收到这个服务端响应之后
会使用本地缓存中的资源
这就是协商缓存
听起来可能有点抽象啊
咱们来具体分析分析这些头信息
这是一个已经有一点过时的http头
它的替代头是cache-control
不过还是要说一说这个http头啊
expires表示的是一个绝对的过期时间
这个资源在本地被缓存之后
如果再次请求这个资源的时候
浏览器就会比对当前的系统时间
是否超过了expires对应的时间
如果系统时间没有超过的话
那就是有效的
浏览器就会直接返回缓存的资源
同时呢
也不需要对这个资源发起请求了
它的状态码会是200
expires的缺点呢就是会参照系统时间
而电脑的系统时间
我们是可以人为设置的
所以说这个属性并不是很有效
这个http头
是浏览器缓存里面最核心的部分
它的可配置属性那也是多的离谱啊
对于浏览器而言
public和private是一样的
没有区别
public表示
资源能被浏览器和中间代理缓存
而private表示只有浏览器能够缓存
而中间代理不能缓存
比如说
服务器下发了一个cache-control为private
max-age=3600的资源
刷新页面之后
流传器就会提示这个资源来自内存缓存
private和public
主要作用于中间代理服务器啊
也就是CDN
no-cache会配合协商缓存一起使用
呃这里要注意啊
no-cache并不是不缓存
而是需要请求服务器
然后根据服务器返回的内容
来决定使不使用缓存
在这个例子中
服务端返回的cache-control就是no-cache
通常呢服务端还会返回etag和last-modified两个头信息
而当我们刷新页面
重新请求这个资源的时候
浏览器就会把刚才传过来的etag和last-modified
赋值给if-none-match和if-modifed-since
服务端在比对etag和last-modified的值之后
再决定是返回304还是返回200
返回304的话
浏览器就会直接使用本地的资源
如果返回200
就表示服务端的资源发生了变动
浏览器也会把这个新的资源缓存在本地
并且应用这个新资源
好吧兄弟们这里已经有点超纲了
这应该是后面要讲的内容
总之呢
no-cache是根据服务端的响应来做相应的资源选择
no-store就比较直接了
就表示不使用缓存
它告诉浏览器你不应该缓存这个资源
浏览器再次访问这个no-store 资源的时候
即使之前请求的响应头中有etag和last-modified
在请求的http头中
都不会携带任何缓存相关的头信息
因为本来就不需要让浏览器缓存
max-age用来设定缓存的有效时长
它的单位是秒
你只需要加上cache-control:max-age=时长
那么资源就能自动地被缓存在本地
当我们刷新页面的时候
浏览器就会提示
这个资源是来自内存缓存
因为这个资源是来自内存缓存啊
而且实际上也不需要
发请求去再次获取这个资源
所以说它消耗的时间非常的短
s-maxage也是指定缓存的有效时长
但它是用来告诉代理服务器的
对于浏览器来讲是没有效果的
对于expires和cache-control同时存在的情况
只要cache-control中设置了max-age或者s-maxage
expires就会失效
再次刷新页面的时候
浏览器提示这个资源来自缓存
而实际上
现在的时间已经超过了expires对应的时间
所以说有冲突的时候
浏览器会应用cache-control里面的值
后面这4个指令
常规使用的时候用的比较少
这里贴上MDN对这几个指令的解释
因为缓存涉及到浏览器缓存和代理服务器缓存
所以看起来会有一点杂
etag表示的是服务端
对于一个资源的唯一标识
要是有个面试官问你
这个etag是怎么生成的呢
那你或许可以回答
我觉得贵司可能不太适合我
我实在想不出
哪个帅x的前端面试官会问
这种问题啊
兄弟们咱说一句不好听的话
你看这HTTP里面的这么多字段
这有哪个字段是需要前端来自己操作的呀
通通甩给后端好吧
吐槽归吐槽啊
咱们继续来了解etag
etag是怎么生成的咱就不用管了
为浏览器的任务就是把它接收到
然后又把它给发送给服务端
举个例子
我们自己写一个服务端
然后服务端返回这个资源的etag
当我刷新页面的时候
浏览器再次请求这个资源
就会带上if-none-match
if-none-match的值
就是最开始服务器返回的etag的值
所以说其实浏览器什么事都没做啊
那什么时候会用到这个etag呢
比如说GitHub上面的一个资源
缓存服务器
指定这个资源在浏览器上面只有300秒的有效期
当资源在本地缓存超过了300秒之后
刚好之前缓存服务器又给了etag和last-modified
我们把页面刷新
因为缓存已经过期了
所以浏览器要向缓存服务器发起请求
这个时候就会把etag赋值给if-none-match
把last-modifed赋值给if-modified-since
请求到达缓存服务器之后呢
发现这个资源的最新版本的etag
和这个if-none-match是一样的
所以就直接返回了304
浏览器直接使用本地缓存的资源就可以了
要是两者不匹配呢
那缓存服务器返回的内容
就和浏览器不带任何缓存字段
重新请求这个资源是一样的
而返回的状态码是200
表示浏览器要缓存这个最新的资源
是用来标识资源的最后更改时间的
last-modified的优先级比etag低
当etag和last-modifed对应的
if-none-match和if-modified-since
同时发给缓存服务器的时候
缓存服务器会只认if-none-match
当然了关于这种优先级什么的
都是约定的一种规范
你自己甚至都可以设计一个
缓存服务器
然后让last-modified的优先级比etag更高
缓存服务器通过比对if-modified-since
和该资源最新的变更时间
来决定返回200还是304
前面已经把和缓存相关的字段都说完了
接下来我们来看几个例子吧
通常缓存在下发给浏览器的时候
cache-control、etag和last-modified三个头信息都会带上
cache-control中的max-age和public基本都会设置
不过也不一定三者都得带上
像这个请求就只返回了etag
而当我刷新页面之后
etag会赋值给if-none-match发送出去
服务端返回的是304
直接使用本地缓存
当我把服务端这个文本给改了之后
再次刷新页面的时候
服务端返回的etag
和我们传递的if-none-match
它是不匹配的
这里服务端就返回了200状态码
让浏览器重新缓存
浏览器访问一个资源呢
我们可以认为有两种形式
第一种是在地址栏里面
直接输入资源的URL
在这种情况下
即使在强缓存的有效期内
浏览器依然会把对这个资源的请求给
发送出去
就好像cache-control:max-age=0一样
实际上在地址栏输入资源URL发起请求的时候
强缓存就会失效
而协商缓存还是有效的
不过在一个复杂的网页上
我们通常都不会直接访问某个资源
如果这个资源
是由网页内的代码加载出来的
那么
它就会遵循强缓存和协商缓存的策略
同样还是这个资源
刷新页面的时候
浏览器提示这个资源是来自内存缓存
也就是强缓存
另外关于刷新页面呢
也有几种不同的情况
关于刷新对缓存的影响
网上很多答案都是错的
ctrl f5和ctrl shift r
它会直接忽略强缓存和协商缓存
即使之前请求的时候
返回头中已经携带过etag和last-modified
在强行刷新页面发起请求的时候
etag和last-modified都不会带上
这种情况下服务端通常都是返回200了
而对于f5 、 control r
或者是地址栏点击刷新按钮
强缓存和协商缓存都是有效的
浏览器会先验证
这个资源是否在强缓存的有效期内
如果并没有过期的话
就会使用本地资源
不用发出这个请求
如果本地资源已经过期
那就会向缓存服务器发起请求
缓存服务器验证etag和last-modified之后
再决定返回304还是200
好了兄弟们本期视频到这里就结束了
视频里面使用到的例子有点多
大家可以反复观看哈
如果你们觉得有用的话
